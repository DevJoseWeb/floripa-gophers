As Novidades do Go 1.10
17 Mar 2018
Tags: golang, 1.10

Ricardo Longa
Software Craftsman, Neoway
ricardo.longa@neoway.com.br
@ricardolonga 

Ellen KÃ¶rbes
e@ellenkorbes.com
@ellenkorbes

* Go 1.10

- Ã‰ o 11Âº release da linguagem.

- LanÃ§ado em 16 de fevereiro de 2018.

- O Go Playground jÃ¡ roda 1.10, teste com:

     fmt.Println(runtime.Version())

* TÃ³picos

Vamos falar sobre:

- O spec da linguagem
- Os ports
- As ferramentas
- A standard library
- Performance

- Que mais?

* Linguagem

* Escove bem os seus bits!

Foi corrigida uma inconsistÃªncia na linguagem:

    const s = 10
    a := make([]byte, 1.0<<s) // Na 1.9: vÃ¡lido.
    _ = a[1.0<<s]             // Na 1.9: erro.

Agora podemos utilizar consistentemente constantes nÃ£o-tipadas como operador em operaÃ§Ãµes de shifting sobre valores nÃ£o constantes (1.0 no exemplo acima). O tipo da constante serÃ¡ `int` nesses casos. (Para mais, [[https://go-review.googlesource.com/c/go/+/60230][clique]].)

Ufa!

* NÃ£o, sÃ©rio.

.image shift.png 575 _

* MÃ©todos

Chamadas de mÃ©todos do tipo `struct{io.Reader}.Read()`, que jÃ¡ eram aceitas pelo compilador, agora sÃ£o oficialmente aceitas pela gramÃ¡tica da linguagem. Exemplo:

    type MyType struct { io.Reader }

    func main() {
        m := MyType{}
        dst := make([]byte, 10)
        l, err := struct{io.Reader}.Read(m, dst)
        _, _, _ = l, err, dst
    }

Mas... erros:

    go.struct { io.Reader }.Read: call to external function
    main.main: relocation target go.struct { io.Reader }.Read not defined
    main.main: undefined: "go.struct { io.Reader }.Read"

Vamos ter que esperar pela 1.11 para poder utilizar.

* Ports

* TÃ©dio:

- FreeBSD: agora requer FreeBSD 10.3 or later
- NetBSD: requer NetBSD 8, que ainda nÃ£o foi lanÃ§ado. GOARCH amd64 e 386 funcionam, arm tÃ¡ quebrado.
- OpenBSD: a prÃ³xima versÃ£o (1.11) vai requerer OpenBSD 6.2.
- Para sistemas MIPS de 32-bits, agora temos uma variÃ¡vel GOMIPS, que pode ser `hardfloat` ou `softfloat`, e serve para determinar se vamos utilizar instruÃ§Ãµes de hardware ou emulaÃ§Ã£o atravÃ©s de software para computaÃ§Ãµes com floating points. Bom saber, caso vocÃª queira rodar cÃ³digo nos processadores MIPS do seu Nintendo 64 ou Playstation 2.

* Importante:

Go 1.10 Ã© a Ãºltima versÃ£o que vai rodar em:

- OS X 10.8 Mountain Lion ou OS X 10.9 Mavericks. Go 1.11 vai rodar somente em OS X 10.10 Yosemite ou mais recentes.
- Windows XP ou Windows Vista. Go 1.11 vai rodar somente em Windows 7 ou mais recentes.

Detalhe:

"And even after Go 1.12 comes out, you can keep using Go 1.10, we just won't fix bugs in it. But if you're happy with it (or Go 1.9 or whatever version), great. You won't get security fixes, but if you are running XP you're not worried about that." â€” [[https://github.com/golang/go/issues/23380#issuecomment-356346724][Russ Cox]]

* Ferramentas

* Set-up:

`GOPATH` virou opcional na 1.8.

`GOROOT` tambem Ã© opcional agora.

`GOTMPDIR` Ã© nova, e determina onde vÃ£o os arquivos temporÃ¡rios.

* Caching

*go*build* agora mantem os builds recentes de packages em cache, em separado das packages instaladas em *$GOROOT/pkg* ou *$GOPATH/pkg*.

Ou seja, antes tinhamos *go*build*-i* e *go*test*-i*:

"The -i flag installs the packages that are dependencies of the target."

Que agora se tornam desnecessÃ¡rios.

Alem disso, *go*build* agora detecta que os packages estÃ£o out-of-date com base nos arquivos fonte, build flags, e metadata dos packages compilados. A Ãºltima data de modificaÃ§Ã£o nÃ£o Ã© mais consultada, ou relevante.

* Caching

Este cache se aplica nÃ£o somente a *go*build* mas tambem a *go*test*.

Para que isso ocorra algumas condiÃ§Ãµes devem ser observadas, dentre elas:

- os testes devem passar
- o executÃ¡vel e a linha de comando devem bater com uma execuÃ§Ã£o anterior
- os arquivos e environment variables devem permanecer os mesmos

Para ignorar o cache, rode com o flag *-count=1*.

E o output dos testes ficarÃ¡ levemente diferente para os testes em cache. Ao invÃ©s de mostrar o tempo de execuÃ§Ã£o, o output serÃ¡ *(cached)*.

* Caching

Exemplo: uma cÃ³pia do Terraform num sistema sem nenhum package instalado ou cache prÃ©-pronto:

- O primeiro *go*test*./...* terminou em aprox. 3 minutos.

    [...]
    FAIL    github.com/hashicorp/terraform/config/module    6.173s
    ok      github.com/hashicorp/terraform/dag      2.712s
    [...]

- O segundo *go*test*./...* terminou  em menos de 40 segundos.

    [...]
    FAIL    github.com/hashicorp/terraform/config/module    7.060s
    ok      github.com/hashicorp/terraform/dag      (cached)
    [...]

*** MÃ¡quina Windows 10 + i7 6700HQ (8 cores) + 32GB RAM

* Testes

AlÃ©m de caching, hÃ¡ algumas diferenÃ§as no *go*test*:

- Algumas verificaÃ§Ãµes do *go*vet* rodam antes dos testes. Ou seja: escreve esse cÃ³digo direito.
- A flag *-coverpkg* agora pode calcular a cobertura de mÃºltiplas packages:
    go test -coverpkg=all -coverprofile cover.out ./...
- A flag *-failfast* possibilita que os testes parem assim que seja encontrada a primeira falha (exceto testes paralelos, que continuam rodando atÃ© terminar).

* build

As seguintes flags do *go*build* agora se aplicam exclusivamente aos packages listados na linha de comando: *-asmflags*, *-gcflags*, *-gccgoflags*, e *-ldflags*.

Exemplo:

 go build -gcflags=-m mypkg

Aqui a flag *-m* se aplica ao package *mypkg*, mas nÃ£o Ã s suas dependÃªncias.

* Um parÃªnteses: slicing com 3 Ã­ndices

Dois Ã­ndices:

.play bytes/slicing.go /START/,/END/

* Um parÃªnteses: slicing com 3 Ã­ndices

TrÃªs Ã­ndices:

.play bytes/slicing2.go /START/,/END/

* gofmt

ExpressÃµes complexas para slicing com 3 Ã­ndices agora tem espaÃ§amento consistente. 

Antes era:

    a[i+j : k:l]

Agora Ã©:

    a[i+j : k : l]

* gofmt

Interfaces com um Ãºnico mÃ©todo escritos em uma linha sÃ³, que costumam ser usadas para tipagem, nÃ£o sÃ£o mais quebradas em diversas linhas:

Antes era:

    if c, ok := v.(interface {
        Close() error
    }); ok {
    }

Agora pode ser:

    if c, ok := v.(interface{ Close() error }); ok {
    }

* gofmt

Se uma literal composta tiver como conteÃºdo somente comentÃ¡rios, agora este comentÃ¡rio serÃ¡ indentado.

Antes:

    var _ = []T{/* comentÃ¡rio */}
    â†“
    var _ = []T{
    /* comentÃ¡rio */
    }

Agora:

    var _ = []T{ /* comentÃ¡rio */ }
    â†“
    var _ = []T{
        /* comentÃ¡rio */
    }

* Outros

- `go`fix` auxilia em migrar imports de `golang.org/x/net/context` para `context` no seu cÃ³digo, mantendo-o compatÃ­vel com versÃµes acima de 1.9.

    go tool fix -r context your/package

- `go`get` agora suporta o SCM Fossil.

- HÃ¡ documentaÃ§Ã£o nova disponÃ­vel sobre diagnÃ³sticos: [[https://golang.org/doc/diagnostics.html]]

* Standard library

- NÃ£o hÃ¡ packages novos

* bytes

Fields, FieldsFunc, Split, SplitAfter retornam slice novo

(exemplos)

* flags

FormataÃ§Ã£o quando tem \n na descriÃ§Ã£o de um flag:

.play flag/main.go /START/,/END/

Antes:

    -x int
        Essa explicaÃ§Ã£o Ã©
    bem longa, sacoÃ©?
    -y int
        Essa Ã© curtinha.

Agora:

    -x int
        Essa explicaÃ§Ã£o Ã©
        bem longa, sacoÃ©?
     -y int
        Essa Ã© curtinha.

* go/doc

Exemplo:

.code coisas/coisas.go

* go/doc

    $ go doc coisas

Antes:

    package coisas // import "github.com/ellenkorbes/floripa-gophers/1.10/coisas"

    func ManyCoisas() []Coisa
    type Coisa
        func NewCoisa() *Coisa

Agora:

    package coisas // import "github.com/ellenkorbes/floripa-gophers/1.10/coisas"

    type Coisa
        func ManyCoisas() []Coisa
        func NewCoisa() *Coisa

* text/template

Agora temos `{{break}}` e `{{continue}}` no `{{range}}`:

.play template/main.go /var tmpl/,/\)\)/

Curiosamente, isto nÃ£o estÃ¡ implementado na package html/template.

* strings

Isso Ã© bastante comum:

    var buf bytes.Buffer
    fmt.Fprintln(&buf, "E aÃ­, galera!")
    fmt.Printf(buf.String())

Mas `.String()` requer alocaÃ§Ãµes de memÃ³ria jÃ¡ que ele converte `[]byte` para `string`.

Agora temos:

	var b strings.Builder
	fmt.Fprintln(&b, "E aÃ­, galera!")
	fmt.Printf(b.String())

* strings

    for i := 0; i < 10000; i++ {
        fmt.Fprintf(w, "ðŸ˜Š")
        out = w.String()
    }

Nesta funÃ§Ã£o temos:

    $ go test -bench=. -benchmem
    goos: darwin
    goarch: amd64
    pkg: github.com/campoy/talks/go1.10/strings
    BenchmarkBuffer-4            100          20861915 ns/op        215641272 B/op     10317 allocs/op
    BenchmarkBuilder-4          3000            535081 ns/op          153647 B/op         22 allocs/op
    PASS
    ok      github.com/campoy/talks/go1.10/strings  3.626s

Mas se comentarmos a linha 

    out = w.String()
    
aÃ­ a performance Ã© levemente pior.

* unicode

novos emoji

* bufio

- Reader e Write agora tem v.Size()

new *Reader.Size* and *Writer.Size* methods report the Reader's or Writer's underlying buffer size

* encoding/json

- DisallowUnknownFields
- Unmarshal can no longer decode into fields inside embedded pointers to unexported struct types, because it cannot initialize the unexported embedded pointer to point at fresh storage.

* math

math - the new functions Round and RoundToEven round their arguments to the nearest floating-point integer; Round rounds a half-integer to its larger integer neighbor (away from zero) while RoundToEven rounds a half-integer to its even integer neighbor

* math/rand 

the new math/rand.Shuffle function and corresponding math/rand.* Rand.Shuffle method shuffle an input sequence *

* net

blablabla

* net/https

blablabla

* os

* outros


* Performance

* Garbage collector:

Mesma coisa.

* Performance de execuÃ§Ã£o:

Mesma coisa.

* Performance de compilaÃ§Ã£o:

10% mais rÃ¡pida!

    $ benchstat go1.9.3.txt go.1.10rc1.txt 
    name       old time/op       new time/op       delta
    Template         234ms Â± 4%        231ms Â± 4%     ~     (p=0.101 n=10+8)
    Unicode          107ms Â± 1%        109ms Â± 6%     ~     (p=0.211 n=9+10)
    GoTypes          742ms Â± 2%        744ms Â± 2%     ~     (p=0.905 n=9+10)
    Compiler         3.50s Â± 3%        3.54s Â± 5%     ~     (p=0.393 n=10+10)
    SSA              6.95s Â± 4%        9.04s Â± 5%  +29.98%  (p=0.000 n=10+10)
    Flate            149ms Â± 2%        147ms Â± 5%   -1.53%  (p=0.035 n=10+9)
    GoParser         189ms Â± 3%        183ms Â± 3%   -3.44%  (p=0.002 n=9+9)
    Reflect          476ms Â± 5%        489ms Â± 6%   +2.90%  (p=0.043 n=10+10)
    Tar              134ms Â± 1%        220ms Â± 3%  +64.14%  (p=0.000 n=9+10)
    XML              258ms Â± 6%        266ms Â± 6%   +2.90%  (p=0.043 n=10+10)
    StdCmd           19.1s Â± 1%        17.1s Â± 3%  -10.57%  (p=0.000 n=10+10)

.caption Following [[https://golang.org/x/tools/cmd/compilebench][https://golang.org/x/tools/cmd/compilebench]].
.caption Run on a Google Compute Engine instance with 8 cores.

* Extras

* UnlockOSThread/LockOSThread

If before, in nested calls, *UnlockOSThread* would need to be called only once to unlock the thread, now it will need to be called as many times as *LockOSThread* was called.

You may have noticed the *<autogenerated>* frame (line) in the stack traces before.
This is now hidden, unless a panic or other issue happens in it.
This also means that if your code would call *runtime.Caller* with a certain number of skip frames, then this change will be a "breaking change" in its behaviour as the *<autogenerated>* frames will not be counted there either.

* Runtime

Go 1.10 also introduces *soft* and *hard*goals* (limits) for *garbage*collection*.

The soft limit is the current value of the GOGC while the hard limit is 10% higher than the soft limit.

Heavy GC reliant applications (so far only benchmarks) shows that thereâ€™s an increase in the heap size of the application.

These limits are not currently configurable, see [[https://golang.org/cl/59970]] for the discussion on it.

* CGO support

C typedefs such as *typedef*X*Y* now are treated as Go aliases. You'll be able to use *C.X* and *C.Y* interchangeably in Go now, as if they would be Go aliases, *type*X*=*Y*.

You can now pass Go strings directly to C. This is done by declaring a C function in a Go file with a parameter type of the special type name *_GoString_*. To access the string length, youâ€™ll need to call *size_t* *_GoStringLen(_GoString_*s)* an in order to get the pointer to the string contents, youâ€™ll need use *const*char* ***_GoStringPtr(_GoString_*s)*.

Some C types that were previously mapped to a pointer type in Go are now mapped to *uintptr* type.
A couple of these types are *CFTypeRef* in Darwin's CoreFoundation framework and the *jobject* in Javaâ€™s JNI interface.
Youâ€™ll need to initialize the values for the affected types with *0* instead of *nil*.
This is a breaking change but thankfully you can fix this quickly and automatically by running

 go tool fix -r cftype your/package or go tool fix -r jni your/package

* Agradecimentos:

- Francesc Campoy
- Florin PÄƒÈ›an
- Dinesh Kumar